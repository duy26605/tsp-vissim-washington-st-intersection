PROGRAM actuated_8PHASES;
/* Actuated control for 8 phases (NEMA dual-ring)
   Simple TSP extension on phases 4 & 8 ONLY:
   - if bus arrives within last 10s before MAXGREEN, allow up to MAXGREEN+10
   - terminate immediately when bus hits check-out detector
*/

VAP_Frequency 10;   /* execute logic 10 times per second */

/************************************************************/
/* CONSTANTS */
CONST
CALLDELAY = 2,      /* seconds before detector registers call */
BUS_WINDOW = 10,    /* seconds before MAXGREEN to become eligible */
BUS_EXT = 10;       /* max additional seconds allowed beyond MAXGREEN */

/************************************************************/
/* ARRAYS */
ARRAY
MAXGREEN[8] = [12, 26, 8, 32, 10, 26, 8, 30],
MINGAP10[8] = [30, 30, 30, 30, 30, 30, 30, 30],
RECALL[8]   = [0,0,0,1,0,0,0,1],   /* recall on throughs (4 & 8 in your plan) */

has_call[8],
no_conflict[8],
confl_call[8],
imminent[8],
early_green[8],
ext_green[8],
rest_green[8],

/* TSP state (arrays only) */
bus_req[8],          /* 1 if bus is between check-in and check-out */
bus_window_ok[8];    /* 1 if within BUS_WINDOW seconds of MAXGREEN */


/************************************************************/
/* SUBROUTINES */

/* ---------- Locking Call ---------- */
SUBROUTINE Locking_call;
IF Current_state(i, red) THEN
   IF (RECALL[i] OR (Occupancy(dk) > CALLDELAY)) THEN
      has_call[i] := 1;
   END;
END.

/* ---------- Non-Locking Call ---------- */
SUBROUTINE NONLocking_call;
IF Current_state(i, red) THEN
   IF (RECALL[i] OR (Occupancy(dk) > CALLDELAY)) THEN
      has_call[i] := 1;
   ELSE
      has_call[i] := 0;
   END;
END.
 
/* ---------- Imminent-to-Rest (normal phases) ---------- */
SUBROUTINE Imminent_to_rest;
IF (imminent[i] AND no_conflict[i]) THEN
   Sg_green(i);
   early_green[i] := 1;
   imminent[i] := 0;
   has_call[i] := 0;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN
   IF ((Headway10(dk) > MINGAP10[i]) OR (T_green(i) >= MAXGREEN[i])) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;
END.

/* ---------- Imminent-to-Rest with LPI + TSP (phase 4) ---------- */
SUBROUTINE Imminent_to_rest_LPI4;

IF (imminent[i] AND no_conflict[i]) THEN
   Start(LPI4);
   IF (LPI4 = 4) THEN
      Sg_green(i);
      early_green[i] := 1;
      imminent[i] := 0;
      has_call[i] := 0;
      Stop(LPI4);
      Reset(LPI4);
   END;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN

   /* 1) If bus clears (check-out 44), terminate immediately */
   IF (Occupancy(44) > 0) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;

   /* 2) Hard stop always at MAXGREEN + BUS_EXT */
   IF (ext_green[i] AND (T_green(i) >= (MAXGREEN[i] + BUS_EXT))) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;

   /* 3) Normal max-out at MAXGREEN only if NOT eligible for TSP */
   IF (ext_green[i] AND (T_green(i) >= MAXGREEN[i])) THEN
      IF NOT (bus_req[i] AND bus_window_ok[i]) THEN
         ext_green[i] := 0;
         rest_green[i] := 1;
      END;
   END;

   /* 4) OPTIONAL: keep normal gap-out when no bus is active */
   IF (ext_green[i] AND NOT bus_req[i]) THEN
      IF (Headway10(dk) > MINGAP10[i]) THEN
         ext_green[i] := 0;
         rest_green[i] := 1;
      END;
   END;

END.

/* ---------- Imminent-to-Rest with LPI + TSP (phase 8) ---------- */
SUBROUTINE Imminent_to_rest_LPI8;

IF (imminent[i] AND no_conflict[i]) THEN
   Start(LPI8);
   IF (LPI8 = 4) THEN
      Sg_green(i);
      early_green[i] := 1;
      imminent[i] := 0;
      has_call[i] := 0;
      Stop(LPI8);
      Reset(LPI8);
   END;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN

   /* 1) If bus clears (check-out 84), terminate immediately */
   IF (Occupancy(84) > 0) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;

   /* 2) Hard stop always at MAXGREEN + BUS_EXT */
   IF (ext_green[i] AND (T_green(i) >= (MAXGREEN[i] + BUS_EXT))) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;

   /* 3) Normal max-out at MAXGREEN only if NOT eligible for TSP */
   IF (ext_green[i] AND (T_green(i) >= MAXGREEN[i])) THEN
      IF NOT (bus_req[i] AND bus_window_ok[i]) THEN
         ext_green[i] := 0;
         rest_green[i] := 1;
      END;
   END;

   /* 4) OPTIONAL: keep normal gap-out when no bus is active */
   IF (ext_green[i] AND NOT bus_req[i]) THEN
      IF (Headway10(dk) > MINGAP10[i]) THEN
         ext_green[i] := 0;
         rest_green[i] := 1;
      END;
   END;

END.

/* ---------- Initialize Early Green ---------- */
SUBROUTINE Initialize_early_green;
IF Current_state(i, green) THEN
   early_green[i] := 1;
END.


/************************************************************/
/* =============== MAIN PROGRAM ============================ */

/* ---- Initialization ---- */
IF sim_timer = 0 THEN
   START(sim_timer);
END;

IF sim_timer <= 5 THEN
   i := 1; GOSUB Initialize_early_green;
   i := 2; GOSUB Initialize_early_green;
   i := 3; GOSUB Initialize_early_green;
   i := 4; GOSUB Initialize_early_green;
   i := 5; GOSUB Initialize_early_green;
   i := 6; GOSUB Initialize_early_green;
   i := 7; GOSUB Initialize_early_green;
   i := 8; GOSUB Initialize_early_green;
END;

/************************************************************/
/* ---- A. Update Calls ---- */
i := 1; dk := 11; GOSUB NONLocking_call;
i := 2; dk := 21; GOSUB NONLocking_call;
i := 3; dk := 31; GOSUB NONLocking_call;
i := 4; dk := 41; GOSUB Locking_call;
i := 5; dk := 51; GOSUB NONLocking_call;
i := 6; dk := 61; GOSUB NONLocking_call;
i := 7; dk := 71; GOSUB NONLocking_call;
i := 8; dk := 81; GOSUB Locking_call;

/************************************************************/
/* ---- A1. SIMPLE BUS REQUEST (must be BEFORE transitions) ---- */

/* clear arrays each step (safe) */
bus_req[1] := 0; bus_req[2] := 0; bus_req[3] := 0; bus_req[4] := 0;
bus_req[5] := 0; bus_req[6] := 0; bus_req[7] := 0; bus_req[8] := 0;

bus_window_ok[1] := 0; bus_window_ok[2] := 0; bus_window_ok[3] := 0; bus_window_ok[4] := 0;
bus_window_ok[5] := 0; bus_window_ok[6] := 0; bus_window_ok[7] := 0; bus_window_ok[8] := 0;

/* Phase 8 (NB): check-in 83, check-out 84 */
bus_req[8] := (Occupancy(83) > 0) AND (Occupancy(84) = 0);

/* Phase 4 (SB): check-in 43, check-out 44 */
bus_req[4] := (Occupancy(43) > 0) AND (Occupancy(44) = 0);

/* Eligible only if bus present AND within last BUS_WINDOW seconds before MAXGREEN */
bus_window_ok[4] := (bus_req[4]) AND ((MAXGREEN[4] - T_green(4)) <= BUS_WINDOW);
bus_window_ok[8] := (bus_req[8]) AND ((MAXGREEN[8] - T_green(8)) <= BUS_WINDOW);

/************************************************************/
/* ---- B. Conflict-Status Logic (realistic NEMA) ---- */
no_conflict[1] :=
    Current_state(2, red)*Current_state(3, red)*
    Current_state(4, red)*Current_state(7, red)*
    Current_state(8, red)*(Remaining_Intergreen(1)=0);

no_conflict[2] :=
    Current_state(1, red)*Current_state(3, red)*
    Current_state(4, red)*Current_state(7, red)*
    Current_state(8, red)*(Remaining_Intergreen(2)=0);

no_conflict[3] :=
    Current_state(1, red)*Current_state(2, red)*
    Current_state(4, red)*Current_state(5, red)*
    Current_state(6, red)*(Remaining_Intergreen(3)=0);

no_conflict[4] :=
    Current_state(1, red)*Current_state(2, red)*
    Current_state(3, red)*Current_state(5, red)*
    Current_state(6, red)*(Remaining_Intergreen(4)=0);

no_conflict[5] :=
    Current_state(6, red)*Current_state(7, red)*
    Current_state(8, red)*Current_state(3, red)*
    Current_state(4, red)*(Remaining_Intergreen(5)=0);

no_conflict[6] :=
    Current_state(5, red)*Current_state(7, red)*
    Current_state(8, red)*Current_state(3, red)*
    Current_state(4, red)*(Remaining_Intergreen(6)=0);

no_conflict[7] :=
    Current_state(5, red)*Current_state(6, red)*
    Current_state(8, red)*Current_state(1, red)*
    Current_state(2, red)*(Remaining_Intergreen(7)=0);

no_conflict[8] :=
    Current_state(5, red)*Current_state(6, red)*
    Current_state(7, red)*Current_state(1, red)*
    Current_state(2, red)*(Remaining_Intergreen(8)=0);

/************************************************************/
/* ---- C. Conflicting Calls ---- */
confl_call[1] := has_call[2] OR has_call[3] OR has_call[4] OR has_call[7] OR has_call[8];
confl_call[2] := has_call[1] OR has_call[3] OR has_call[4] OR has_call[7] OR has_call[8];
confl_call[3] := has_call[1] OR has_call[2] OR has_call[4] OR has_call[5] OR has_call[6];
confl_call[4] := has_call[1] OR has_call[2] OR has_call[3] OR has_call[5] OR has_call[6];
confl_call[5] := has_call[3] OR has_call[4] OR has_call[6] OR has_call[7] OR has_call[8];
confl_call[6] := has_call[3] OR has_call[4] OR has_call[5] OR has_call[7] OR has_call[8];
confl_call[7] := has_call[1] OR has_call[2] OR has_call[5] OR has_call[6] OR has_call[8];
confl_call[8] := has_call[1] OR has_call[2] OR has_call[5] OR has_call[6] OR has_call[7];

/************************************************************/
/* ---- D. Phase Transition Evaluation ---- */
i := 1; dk := 12; GOSUB Imminent_to_rest;
i := 2; dk := 22; GOSUB Imminent_to_rest;
i := 3; dk := 32; GOSUB Imminent_to_rest;
i := 4; dk := 42; GOSUB Imminent_to_rest_LPI4;
i := 5; dk := 52; GOSUB Imminent_to_rest;
i := 6; dk := 62; GOSUB Imminent_to_rest;
i := 7; dk := 72; GOSUB Imminent_to_rest;
i := 8; dk := 82; GOSUB Imminent_to_rest_LPI8;

/************************************************************/
/* ---- OPTIONAL: Dummy signals to verify TSP visually ---- */
/* SG 9: any bus check-in active */
IF ((Occupancy(83) > 0) OR (Occupancy(43) > 0)) THEN
   Sg_green(9);
ELSE
   Sg_red(9);
END;

/* SG10: bus_req active (bus between check-in and check-out) */
IF (bus_req[4] OR bus_req[8]) THEN
   Sg_green(10);
ELSE
   Sg_red(10);
END;

/* SG11: TSP eligible window true */
IF (bus_window_ok[4] OR bus_window_ok[8]) THEN
   Sg_green(11);
ELSE
   Sg_red(11);
END;

/* SG12: check-out hit */
IF ((Occupancy(84) > 0) OR (Occupancy(44) > 0)) THEN
   Sg_green(12);
ELSE
   Sg_red(12);
END;

/************************************************************/
/* ---- E. Phase Sequencing and Barrier Logic ---- */

/* within-ring transitions */
IF rest_green[1] THEN
   rest_green[1] := 0;
   Sg_red(1);
   imminent[2] := 1;
END;

IF rest_green[3] THEN
   rest_green[3] := 0;
   Sg_red(3);
   imminent[4] := 1;
END;

IF rest_green[5] THEN
   rest_green[5] := 0;
   Sg_red(5);
   imminent[6] := 1;
END;

IF rest_green[7] THEN
   rest_green[7] := 0;
   Sg_red(7);
   imminent[8] := 1;
END;

/* ---- Barrier 1: between 2 & 6 ---- */
IF (rest_green[2] AND rest_green[6]) THEN
   rest_green[2] := 0;
   rest_green[6] := 0;
   Sg_red(2);
   Sg_red(6);

   IF has_call[3] THEN
      imminent[3] := 1;
   ELSE
      imminent[4] := 1;
   END;

   IF has_call[7] THEN
      imminent[7] := 1;
   ELSE
      imminent[8] := 1;
   END;
END;

/* ---- Barrier 2: between 4 & 8 ---- */
IF (rest_green[4] AND rest_green[8]) THEN
   rest_green[4] := 0;
   rest_green[8] := 0;
   Sg_red(4);
   Sg_red(8);

   IF has_call[1] THEN
      imminent[1] := 1;
   ELSE
      imminent[2] := 1;
   END;

   IF has_call[5] THEN
      imminent[5] := 1;
   ELSE
      imminent[6] := 1;
   END;
END.

/************************************************************/
/* END PROGRAM */
END.
