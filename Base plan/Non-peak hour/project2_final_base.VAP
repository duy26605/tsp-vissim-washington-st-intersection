PROGRAM actuated_8PHASES;
/* Actuated control for 8 phases (NEMA dual-ring) */
/* Version 3a corrected 2025. */
/* Uses intergreen to create visible red clearance. */

VAP_Frequency 10;   /* execute logic 10 times per second */

/************************************************************/
/* CONSTANTS */
CONST
CALLDELAY = 2;      /* seconds before detector registers call */

/************************************************************/
/* ARRAYS */
ARRAY
MAXGREEN[8] = [12, 26, 8, 32, 10, 26, 8, 30],
MINGAP10[8] = [30, 30, 30, 30, 30, 30, 30, 30],
RECALL[8]   = [0,0,0,1,0,0,0,1],   /* recall on throughs */
has_call[8],
no_conflict[8],
confl_call[8],
imminent[8],
early_green[8],
ext_green[8],
rest_green[8];

/************************************************************/
/* SUBROUTINES */

/* ---------- Locking Call ---------- */
SUBROUTINE Locking_call;
/* sets a locking call with a delay of CALLDELAY seconds */
IF Current_state(i, red) THEN
   IF (RECALL[i] OR (Occupancy(dk) > CALLDELAY)) THEN
      has_call[i] := 1;
   END;
END.



SUBROUTINE NONLocking_call;
	/* Sets a locking call with a delay of CALLDELAY seconds */
    	/* Implicit inputs: i (signal group), dk (call detector), RECALL[] */ 

IF Current_state(i, red)  THEN      			/* Current state() is a VAP function  */
   IF (RECALL[i] OR (Occupancy(dk)> CALLDELAY))  THEN  	/* if RECALL is true, dk's value won't matter */
      has_call[i] := 1;
   ELSE 
      has_call[i] :=0;
   END
END.   /* The period ends the subroutine */

 
/************************************************************/
/* ---------- Imminent-to-Rest Transition ---------- */
SUBROUTINE Imminent_to_rest;
/* transitions between states from imminent to rest_green */
IF (imminent[i] AND no_conflict[i]) THEN
   Sg_green(i);
   early_green[i] := 1;
   imminent[i] := 0;
   has_call[i] := 0;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN
   IF ((Headway10(dk) > MINGAP10[i]) OR (T_green(i) >= MAXGREEN[i])) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;
END.


SUBROUTINE Imminent_to_rest_LPI4;
/* transitions between states from imminent to rest_green */
IF (imminent[i] AND no_conflict[i]) THEN
   Start(LPI4); 
   IF (LPI4=4) THEN
        Sg_green(i);
        early_green[i] := 1;
        imminent[i] := 0;
        has_call[i] := 0;
        Stop(LPI4);
        Reset(LPI4);
   END;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN
   IF ((Headway10(dk) > MINGAP10[i]) OR (T_green(i) >= MAXGREEN[i])) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;
END.




SUBROUTINE Imminent_to_rest_LPI8;
/* transitions between states from imminent to rest_green */
IF (imminent[i] AND no_conflict[i]) THEN
   Start(LPI8); 
   IF (LPI8=4) THEN
        Sg_green(i);
        early_green[i] := 1;
        imminent[i] := 0;
        has_call[i] := 0;
        Stop(LPI8);
        Reset(LPI8);
   END;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN
   IF ((Headway10(dk) > MINGAP10[i]) OR (T_green(i) >= MAXGREEN[i])) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;
END.




 
/************************************************************/
/* ---------- Initialize Early Green ---------- */
SUBROUTINE Initialize_early_green;
IF Current_state(i, green) THEN
   early_green[i] := 1;
END.

/************************************************************/
/* =============== MAIN PROGRAM ============================ */

/* ---- Initialization ---- */
IF sim_timer = 0 THEN
   START(sim_timer);
END;

IF sim_timer <= 5 THEN
   i := 1; GOSUB Initialize_early_green;   
	i := 2; GOSUB Initialize_early_green;
   i := 3; GOSUB Initialize_early_green;   
	i := 4; GOSUB Initialize_early_green;
   i := 5; GOSUB Initialize_early_green;   
	i := 6; GOSUB Initialize_early_green;
   i := 7; GOSUB Initialize_early_green;   
	i := 8; GOSUB Initialize_early_green;
END;


/************************************************************/
/* ---- A. Update Calls ---- */
i := 1; dk := 11; GOSUB NONLocking_call;
i := 2; dk := 21; GOSUB NONLocking_call;
i := 3; dk := 31; GOSUB NONLocking_call;
i := 4; dk := 41; GOSUB Locking_call;
i := 5; dk := 51; GOSUB NONLocking_call;
i := 6; dk := 61; GOSUB NONLocking_call;
i := 7; dk := 71; GOSUB NONLocking_call;
i := 8; dk := 81; GOSUB Locking_call;


/************************************************************/
/* ---- B. Conflict-Status Logic (realistic NEMA) ---- */
no_conflict[1] :=
    Current_state(2, red)*Current_state(3, red)*
    Current_state(4, red)*Current_state(7, red)*
    Current_state(8, red)*(Remaining_Intergreen(1)=0);

no_conflict[2] :=
    Current_state(1, red)*Current_state(3, red)*
    Current_state(4, red)*Current_state(7, red)*
    Current_state(8, red)*(Remaining_Intergreen(2)=0);

no_conflict[3] :=
    Current_state(1, red)*Current_state(2, red)*
    Current_state(4, red)*Current_state(5, red)*
    Current_state(6, red)*(Remaining_Intergreen(3)=0);

no_conflict[4] :=
    Current_state(1, red)*Current_state(2, red)*
    Current_state(3, red)*Current_state(5, red)*
    Current_state(6, red)*(Remaining_Intergreen(4)=0);

no_conflict[5] :=
    Current_state(6, red)*Current_state(7, red)*
    Current_state(8, red)*Current_state(3, red)*
    Current_state(4, red)*(Remaining_Intergreen(5)=0);

no_conflict[6] :=
    Current_state(5, red)*Current_state(7, red)*
    Current_state(8, red)*Current_state(3, red)*
    Current_state(4, red)*(Remaining_Intergreen(6)=0);

no_conflict[7] :=
    Current_state(5, red)*Current_state(6, red)*
    Current_state(8, red)*Current_state(1, red)*
    Current_state(2, red)*(Remaining_Intergreen(7)=0);

no_conflict[8] :=
    Current_state(5, red)*Current_state(6, red)*
    Current_state(7, red)*Current_state(1, red)*
    Current_state(2, red)*(Remaining_Intergreen(8)=0);

/************************************************************/
/* ---- C. Conflicting Calls ---- */
confl_call[1] := has_call[2] OR has_call[3] OR has_call[4] OR has_call[7] OR has_call[8];
confl_call[2] := has_call[1] OR has_call[3] OR has_call[4] OR has_call[7] OR has_call[8];
confl_call[3] := has_call[1] OR has_call[2] OR has_call[4] OR has_call[5] OR has_call[6];
confl_call[4] := has_call[1] OR has_call[2] OR has_call[3] OR has_call[5] OR has_call[6];
confl_call[5] := has_call[3] OR has_call[4] OR has_call[6] OR has_call[7] OR has_call[8];
confl_call[6] := has_call[3] OR has_call[4] OR has_call[5] OR has_call[7] OR has_call[8];
confl_call[7] := has_call[1] OR has_call[2] OR has_call[5] OR has_call[6] OR has_call[8];
confl_call[8] := has_call[1] OR has_call[2] OR has_call[5] OR has_call[6] OR has_call[7];


/************************************************************/
/* ---- D. Phase Transition Evaluation ---- */
i := 1; dk := 12; GOSUB Imminent_to_rest;
i := 2; dk := 22; GOSUB Imminent_to_rest;
i := 3; dk := 32; GOSUB Imminent_to_rest;
i := 4; dk := 42; GOSUB Imminent_to_rest_LPI4;
i := 5; dk := 52; GOSUB Imminent_to_rest;
i := 6; dk := 62; GOSUB Imminent_to_rest;
i := 7; dk := 72; GOSUB Imminent_to_rest;
i := 8; dk := 82; GOSUB Imminent_to_rest_LPI8;

/************************************************************/
/* ---- E. Phase Sequencing and Barrier Logic ---- */

/* within-ring transitions */
IF rest_green[1] THEN
   rest_green[1] := 0;
   Sg_red(1);
   imminent[2] := 1;
END;

IF rest_green[3] THEN
   rest_green[3] := 0;
   Sg_red(3);
   imminent[4] := 1;
END;

IF rest_green[5] THEN
   rest_green[5] := 0;
   Sg_red(5);
   imminent[6] := 1;
END;

IF rest_green[7] THEN
   rest_green[7] := 0;
   Sg_red(7);
   imminent[8] := 1;
END;

/* ---- Barrier 1: between 2 & 6 ---- */
IF (rest_green[2] AND rest_green[6]) THEN
   rest_green[2] := 0;
   rest_green[6] := 0;
   Sg_red(2);
   Sg_red(6);
   IF has_call[3] THEN
      imminent[3] := 1;
   ELSE
      imminent[4] := 1;
   END;
   IF has_call[7] THEN
      imminent[7] := 1;
   ELSE
      imminent[8] := 1;
   END;
END;

/* ---- Barrier 2: between 4 & 8 ---- */
IF (rest_green[4] AND rest_green[8]) THEN
   rest_green[4] := 0;
   rest_green[8] := 0;
   Sg_red(4);
   Sg_red(8);
   IF has_call[1] THEN
      imminent[1] := 1;
   ELSE
      imminent[2] := 1;
   END;
   IF has_call[5] THEN
      imminent[5] := 1;
   ELSE
      imminent[6] := 1;
   END;
END.

/************************************************************/
/* END PROGRAM */
END.
