PROGRAM actuated_8PHASES;
/* Actuated control for 8 phases (NEMA dual-ring) */
/* Version 3a corrected 2025. */
/* Uses intergreen to create visible red clearance. */

VAP_Frequency 10;   /* execute logic 10 times per second */

/************************************************************/
/* CONSTANTS */
CONST
BUS_EXT_MAX = 10,     /* maximum bus extension (seconds) */
BUS_WINDOW  = 10,     /* extension eligibility window (seconds) */
CALLDELAY = 2;      /* seconds before detector registers call */

/************************************************************/
/* ARRAYS */
ARRAY
MAXGREEN[8] = [12, 26, 8, 32, 10, 26, 8, 30],
MINGAP10[8] = [30, 30, 30, 999, 30, 30, 30, 999],
RECALL[8]   = [0,0,0,1,0,0,0,1],   /* recall on throughs */
has_call[8],
no_conflict[8],
confl_call[8],
imminent[8],
early_green[8],
ext_green[8],
rest_green[8],
bus_req[8],        /* 1 if bus is between check-in and check-out */
bus_ext_t[8],      /* seconds of bus extension already used */
bus_window_ok[8];  /* 1 if phase is inside extension window */


/************************************************************/
/* SUBROUTINES */

/* ---------- Locking Call ---------- */
SUBROUTINE Locking_call;
/* sets a locking call with a delay of CALLDELAY seconds */
IF Current_state(i, red) THEN
   IF (RECALL[i] OR (Occupancy(dk) > CALLDELAY)) THEN
      has_call[i] := 1;
   END;
END.



SUBROUTINE NONLocking_call;
	/* Sets a locking call with a delay of CALLDELAY seconds */
    	/* Implicit inputs: i (signal group), dk (call detector), RECALL[] */ 

IF Current_state(i, red)  THEN      			/* Current state() is a VAP function  */
   IF (RECALL[i] OR (Occupancy(dk)> CALLDELAY))  THEN  	/* if RECALL is true, dk's value won't matter */
      has_call[i] := 1;
   ELSE 
      has_call[i] :=0;
   END;
END.   /* The period ends the subroutine */

 
/************************************************************/
/* ---------- Imminent-to-Rest Transition ---------- */
SUBROUTINE Imminent_to_rest;
/* transitions between states from imminent to rest_green */
IF (imminent[i] AND no_conflict[i]) THEN
   Sg_green(i);
   early_green[i] := 1;
   imminent[i] := 0;
   has_call[i] := 0;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN
   IF ((Headway10(dk) > MINGAP10[i]) OR (T_green(i) >= MAXGREEN[i])) THEN
      ext_green[i] := 0;
      rest_green[i] := 1;
   END;
END.


SUBROUTINE Imminent_to_rest_LPI4;

IF (imminent[i] AND no_conflict[i]) THEN
   Start(LPI4);
   IF (LPI4 = 4) THEN
      Sg_green(i);
      early_green[i] := 1;
      imminent[i] := 0;
      has_call[i] := 0;
      bus_ext_t[i] := 0;
      Stop(LPI4);
      Reset(LPI4);
   END;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN

   /* accumulate bus extension */
   IF (bus_req[i] AND bus_window_ok[i] AND (bus_ext_t[i] < BUS_EXT_MAX)) THEN
      bus_ext_t[i] := bus_ext_t[i] + 0.1;
   END;

   /* ---------- BUS-AWARE MAX OUT ---------- */

/* absolute hard stop: MAXGREEN + BUS_EXT_MAX */
    IF (T_green(i) >= (MAXGREEN[i] + BUS_EXT_MAX)) THEN
       ext_green[i] := 0;
       rest_green[i] := 1;
    END;

/* soft max-out at MAXGREEN (only if bus NOT eligible) */
    IF (T_green(i) >= MAXGREEN[i]) THEN
       IF NOT (bus_req[i] AND bus_window_ok[i]) THEN
          ext_green[i] := 0;
          rest_green[i] := 1;
       END;
    END;
END.









SUBROUTINE Imminent_to_rest_LPI8;
/* transitions between states from imminent to rest_green */
IF (imminent[i] AND no_conflict[i]) THEN
   Start(LPI8); 
   IF (LPI8=4) THEN
        Sg_green(i);
        early_green[i] := 1;
        imminent[i] := 0;
        has_call[i] := 0;
        bus_ext_t[i] := 0;
        Stop(LPI8);
        Reset(LPI8);
   END;
END;

IF (early_green[i] AND confl_call[i] AND (T_green(i) >= T_green_min(i))) THEN
   early_green[i] := 0;
   ext_green[i] := 1;
END;

IF (ext_green[i]) THEN

   /* accumulate bus extension */
   IF (bus_req[i] AND bus_window_ok[i] AND (bus_ext_t[i] < BUS_EXT_MAX)) THEN
      bus_ext_t[i] := bus_ext_t[i] + 0.1;
   END;

   /* ---------- BUS-AWARE MAX OUT ---------- */

/* absolute hard stop: MAXGREEN + BUS_EXT_MAX */
    IF (T_green(i) >= (MAXGREEN[i] + BUS_EXT_MAX)) THEN
       ext_green[i] := 0;
       rest_green[i] := 1;
    END;

/* soft max-out at MAXGREEN (only if bus NOT eligible) */
    IF (T_green(i) >= MAXGREEN[i]) THEN
       IF NOT (bus_req[i] AND bus_window_ok[i]) THEN
          ext_green[i] := 0;
          rest_green[i] := 1;
       END;
    END;
END.


 
/************************************************************/
/* ---------- Initialize Early Green ---------- */
SUBROUTINE Initialize_early_green;
IF Current_state(i, green) THEN
   early_green[i] := 1;
END.

/************************************************************/
/* =============== MAIN PROGRAM ============================ */

/* ---- Initialization ---- */
IF sim_timer = 0 THEN
   START(sim_timer);
END;

IF sim_timer <= 5 THEN
   i := 1; GOSUB Initialize_early_green;   
	i := 2; GOSUB Initialize_early_green;
   i := 3; GOSUB Initialize_early_green;   
	i := 4; GOSUB Initialize_early_green;
   i := 5; GOSUB Initialize_early_green;   
	i := 6; GOSUB Initialize_early_green;
   i := 7; GOSUB Initialize_early_green;   
	i := 8; GOSUB Initialize_early_green;
END;


/************************************************************/
/* ---- A. Update Calls ---- */
i := 1; dk := 11; GOSUB NONLocking_call;
i := 2; dk := 21; GOSUB NONLocking_call;
i := 3; dk := 31; GOSUB NONLocking_call;
i := 4; dk := 41; GOSUB Locking_call;
i := 5; dk := 51; GOSUB NONLocking_call;
i := 6; dk := 61; GOSUB NONLocking_call;
i := 7; dk := 71; GOSUB NONLocking_call;
i := 8; dk := 81; GOSUB Locking_call;

/*********** A0. BUS REQUEST ***********/

/* reset every step (arrays persist) */
bus_req[1] := 0; bus_req[2] := 0; bus_req[3] := 0; bus_req[4] := 0;
bus_req[5] := 0; bus_req[6] := 0; bus_req[7] := 0; bus_req[8] := 0;

/* NB bus affects phase 8 */
bus_req[8] := (Occupancy(83) > 0) * (Occupancy(84) = 0);

/* SB bus affects phase 4 */
bus_req[4] := (Occupancy(43) > 0) * (Occupancy(44) = 0);



/************************************************************/
/* ---- B. Conflict-Status Logic (realistic NEMA) ---- */
no_conflict[1] :=
    Current_state(2, red)*Current_state(3, red)*
    Current_state(4, red)*Current_state(7, red)*
    Current_state(8, red)*(Remaining_Intergreen(1)=0);

no_conflict[2] :=
    Current_state(1, red)*Current_state(3, red)*
    Current_state(4, red)*Current_state(7, red)*
    Current_state(8, red)*(Remaining_Intergreen(2)=0);

no_conflict[3] :=
    Current_state(1, red)*Current_state(2, red)*
    Current_state(4, red)*Current_state(5, red)*
    Current_state(6, red)*(Remaining_Intergreen(3)=0);

no_conflict[4] :=
    Current_state(1, red)*Current_state(2, red)*
    Current_state(3, red)*Current_state(5, red)*
    Current_state(6, red)*(Remaining_Intergreen(4)=0);

no_conflict[5] :=
    Current_state(6, red)*Current_state(7, red)*
    Current_state(8, red)*Current_state(3, red)*
    Current_state(4, red)*(Remaining_Intergreen(5)=0);

no_conflict[6] :=
    Current_state(5, red)*Current_state(7, red)*
    Current_state(8, red)*Current_state(3, red)*
    Current_state(4, red)*(Remaining_Intergreen(6)=0);

no_conflict[7] :=
    Current_state(5, red)*Current_state(6, red)*
    Current_state(8, red)*Current_state(1, red)*
    Current_state(2, red)*(Remaining_Intergreen(7)=0);

no_conflict[8] :=
    Current_state(5, red)*Current_state(6, red)*
    Current_state(7, red)*Current_state(1, red)*
    Current_state(2, red)*(Remaining_Intergreen(8)=0);

/************************************************************/
/* ---- C. Conflicting Calls ---- */
confl_call[1] := has_call[2] OR has_call[3] OR has_call[4] OR has_call[7] OR has_call[8];
confl_call[2] := has_call[1] OR has_call[3] OR has_call[4] OR has_call[7] OR has_call[8];
confl_call[3] := has_call[1] OR has_call[2] OR has_call[4] OR has_call[5] OR has_call[6];
confl_call[4] := has_call[1] OR has_call[2] OR has_call[3] OR has_call[5] OR has_call[6];
confl_call[5] := has_call[3] OR has_call[4] OR has_call[6] OR has_call[7] OR has_call[8];
confl_call[6] := has_call[3] OR has_call[4] OR has_call[5] OR has_call[7] OR has_call[8];
confl_call[7] := has_call[1] OR has_call[2] OR has_call[5] OR has_call[6] OR has_call[8];
confl_call[8] := has_call[1] OR has_call[2] OR has_call[5] OR has_call[6] OR has_call[7];


/*********** C0. BUS EXTENSION WINDOW ***********/

bus_window_ok[1] := (MAXGREEN[1] - T_green(1)) <= BUS_WINDOW;
bus_window_ok[2] := (MAXGREEN[2] - T_green(2)) <= BUS_WINDOW;
bus_window_ok[3] := (MAXGREEN[3] - T_green(3)) <= BUS_WINDOW;
bus_window_ok[4] := (MAXGREEN[4] - T_green(4)) <= BUS_WINDOW;
bus_window_ok[5] := (MAXGREEN[5] - T_green(5)) <= BUS_WINDOW;
bus_window_ok[6] := (MAXGREEN[6] - T_green(6)) <= BUS_WINDOW;
bus_window_ok[7] := (MAXGREEN[7] - T_green(7)) <= BUS_WINDOW;
bus_window_ok[8] := (MAXGREEN[8] - T_green(8)) <= BUS_WINDOW;

/*********** Dummy ***********/
IF ((Occupancy(83)) > 0 OR (Occupancy(43) > 0)) THEN
   Sg_green(9);
ELSE
   Sg_red(9);
END;

IF ((bus_req[4] AND bus_window_ok[4]) OR
    (bus_req[8] AND bus_window_ok[8])) THEN
   Sg_green(10);
ELSE
   Sg_red(10);
END;


IF ((ext_green[4] AND bus_req[4] AND bus_window_ok[4]) OR
    (ext_green[8] AND bus_req[8] AND bus_window_ok[8])) THEN
   Sg_green(11);
ELSE
   Sg_red(11);
END;

IF ((Occupancy(84) > 0) OR (Occupancy(44) > 0)) THEN
   Sg_green(12);
ELSE
   Sg_red(12);
END;



/************************************************************/
/* ---- D. Phase Transition Evaluation ---- */
i := 1; dk := 12; GOSUB Imminent_to_rest;
i := 2; dk := 22; GOSUB Imminent_to_rest;
i := 3; dk := 32; GOSUB Imminent_to_rest;
i := 4; dk := 42; GOSUB Imminent_to_rest_LPI4;
i := 5; dk := 52; GOSUB Imminent_to_rest;
i := 6; dk := 62; GOSUB Imminent_to_rest;
i := 7; dk := 72; GOSUB Imminent_to_rest;
i := 8; dk := 82; GOSUB Imminent_to_rest_LPI8;





/************************************************************/
/* ---- E. Phase Sequencing and Barrier Logic ---- */

/* within-ring transitions */
IF rest_green[1] THEN
   rest_green[1] := 0;
   Sg_red(1);
   imminent[2] := 1;
END;

IF rest_green[3] THEN
   rest_green[3] := 0;
   Sg_red(3);
   imminent[4] := 1;
END;

IF rest_green[5] THEN
   rest_green[5] := 0;
   Sg_red(5);
   imminent[6] := 1;
END;

IF rest_green[7] THEN
   rest_green[7] := 0;
   Sg_red(7);
   imminent[8] := 1;
END;

/* ---- Barrier 1: between 2 & 6 ---- */
IF (rest_green[2] AND rest_green[6]) THEN
   rest_green[2] := 0;
   rest_green[6] := 0;
   Sg_red(2);
   Sg_red(6);
   IF has_call[3] THEN
      imminent[3] := 1;
   ELSE
      imminent[4] := 1;
   END;
   IF has_call[7] THEN
      imminent[7] := 1;
   ELSE
      imminent[8] := 1;
   END;
END;

/* ---- Barrier 2: between 4 & 8 ---- */
IF (rest_green[4] AND rest_green[8]) THEN
   rest_green[4] := 0;
   rest_green[8] := 0;
   Sg_red(4);
   Sg_red(8);
   IF has_call[1] THEN
      imminent[1] := 1;
   ELSE
      imminent[2] := 1;
   END;
   IF has_call[5] THEN
      imminent[5] := 1;
   ELSE
      imminent[6] := 1;
   END;
END.


/************************************************************/
/* END PROGRAM */
END.
